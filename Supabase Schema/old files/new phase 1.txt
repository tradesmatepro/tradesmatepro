-- ========================================
-- 1. ENUM TYPES
-- ========================================
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TYPE company_status_enum AS ENUM ('ACTIVE', 'INACTIVE');
CREATE TYPE customer_status_enum AS ENUM ('ACTIVE', 'INACTIVE');
CREATE TYPE user_status_enum AS ENUM ('ACTIVE', 'INACTIVE');

CREATE TYPE work_order_status_enum AS ENUM (
  'QUOTE','SENT','ACCEPTED','REJECTED',
  'SCHEDULED','IN_PROGRESS','COMPLETED',
  'CANCELLED','INVOICED'
);

CREATE TYPE invoice_status_enum AS ENUM (
  'UNPAID','PARTIALLY_PAID','PAID','OVERDUE','VOID'
);

-- ========================================
-- 2. CORE ENTITIES
-- ========================================

-- Companies
CREATE TABLE public.companies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    status company_status_enum DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Customers
CREATE TABLE public.customers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    phone TEXT,
    status customer_status_enum DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Users
CREATE TABLE public.users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    status user_status_enum DEFAULT 'ACTIVE',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Work Orders
CREATE TABLE public.work_orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES public.customers(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    description TEXT,
    status work_order_status_enum DEFAULT 'QUOTE',
    estimated_duration INTEGER,
    total_amount NUMERIC(12,2) DEFAULT 0,
    created_by UUID REFERENCES public.users(id),
    updated_by UUID REFERENCES public.users(id),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Invoices
CREATE TABLE public.invoices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,
    work_order_id UUID REFERENCES public.work_orders(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES public.customers(id) ON DELETE CASCADE,
    status invoice_status_enum DEFAULT 'UNPAID',
    total_amount NUMERIC(12,2) DEFAULT 0,
    due_date TIMESTAMPTZ,
    created_by UUID REFERENCES public.users(id),
    updated_by UUID REFERENCES public.users(id),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Invoice line items
CREATE TABLE public.invoice_line_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,
    invoice_id UUID REFERENCES public.invoices(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    unit_price NUMERIC(12,2) DEFAULT 0,
    total NUMERIC(12,2) GENERATED ALWAYS AS (quantity * unit_price) STORED
);

-- Work Order Audit Log
CREATE TABLE public.work_order_audit_log (
    id BIGSERIAL PRIMARY KEY,
    work_order_id UUID REFERENCES public.work_orders(id) ON DELETE CASCADE,
    company_id UUID REFERENCES public.companies(id) ON DELETE CASCADE,
    action TEXT,
    old_status TEXT,
    new_status TEXT,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- ========================================
-- 3. FUNCTIONS & TRIGGERS
-- ========================================

-- Updated_at automation
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at_work_orders
BEFORE UPDATE ON public.work_orders
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_invoices
BEFORE UPDATE ON public.invoices
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_customers
BEFORE UPDATE ON public.customers
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_users
BEFORE UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Work order audit trigger
CREATE OR REPLACE FUNCTION log_work_order_change()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF TG_OP = 'UPDATE' AND OLD.status IS DISTINCT FROM NEW.status THEN
    INSERT INTO public.work_order_audit_log (
      work_order_id, company_id, action, old_status, new_status, details
    ) VALUES (
      NEW.id, NEW.company_id, 'status_changed',
      OLD.status::text, NEW.status::text,
      jsonb_build_object('old_total', OLD.total_amount, 'new_total', NEW.total_amount)
    );
  END IF;
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_log_work_order_change
AFTER UPDATE ON public.work_orders
FOR EACH ROW EXECUTE FUNCTION log_work_order_change();

-- ========================================
-- 4. VIEWS (safe, no broken enums)
-- ========================================

CREATE OR REPLACE VIEW public.work_orders_history AS
SELECT * FROM public.work_orders;

CREATE OR REPLACE VIEW public.closed_jobs AS
SELECT * FROM public.work_orders
WHERE status = 'COMPLETED';

CREATE OR REPLACE VIEW public.quotes AS
SELECT * FROM public.work_orders
WHERE status = 'QUOTE';

CREATE OR REPLACE VIEW public.open_invoices AS
SELECT 
    i.id,
    i.work_order_id,
    i.customer_id,
    c.name AS customer_name,
    i.status,
    i.total_amount,
    i.due_date,
    i.created_at,
    i.updated_at
FROM public.invoices i
JOIN public.customers c ON c.id = i.customer_id
WHERE i.status = 'UNPAID';

CREATE OR REPLACE VIEW public.jobs_with_payment_status AS
SELECT 
    wo.*,
    i.status AS invoice_status
FROM public.work_orders wo
LEFT JOIN public.invoices i ON i.work_order_id = wo.id;
